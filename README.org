A collection of useful scripts to run with [[https://babashka.org/][Babashka]]!

* Table of Contents                                                     :TOC:
- [[#bb-components][bb-components]]
  - [[#pre-requisites][Pre-requisites]]
  - [[#compiling-the-bb-components-script][Compiling the bb-components script]]
  - [[#using-the-bb-components-script][Using the bb-components script]]
- [[#bb-plain-text-tabs][bb-plain-text-tabs]]
  - [[#pre-requisites-1][Pre-requisites]]
  - [[#compiling-the-bb-plain-text-tabs-script][Compiling the bb-plain-text-tabs script]]
  - [[#using-the-bb-plain-text-tabs-script][Using the bb-plain-text-tabs script]]

* bb-components

A script to find all the components that you should deploy your code to.

If a namespace contains a ~-main~ function in it, it represents an independently deployable 'component'. A monolith repo can have many such components. For any code change, this script quickly finds all the components affected by the change. This ensures that something is not accidentally missed in testing. It is also a great way to find your core namespaces and to identify areas requiring refactoring.

#+begin_example
  ✦ ➜ bb-components --help
  List all the release components that you should deploy your code to.

  Usage: bb-components [options] C1 C2

  Options:
    -e, --exclude-paths EXCLUDE-DIR  ["test/" "qa/"]  Directory to exclude in the search. Pass option multiple times to exclude multiple dirs.
    -s, --source-paths SOURCE-DIR    ["src/"]         Directory where source files are stored. Pass option multiple times to include multiple dirs.
    -t, --timeout TIMEOUT            60               Program times out in TIMEOUT seconds.
    -v, --verbose                                     Prints out the actual files due to which a component is selected.
        --stdin                                       Accept list of files from standard input. Ignore C1/C2 args in this case. List should be in the same format as generated by 'git diff --name-only'
    -h, --help                                        Prints out this message.

  C1 and C2 are Git SHAs / Refs / Tags representing the changed code.
  The default value for C1 is HEAD and C2 is master
  Examples:
     bb-components                       # Calculate components for changes between HEAD and master
     bb-components release-branch master # Calculate components for changes between release-branch and master
     bb-components -t 60 -e test -e qa   # Changes between HEAD and master, but ignore changes in test/ and qa/ dirs. Abort if the run takes more than 60s.
     bb-components -v                    # Print components as well as the specific files due to which the component was selected.
     git diff a..b --name-only | bb-components --stdin # Calculate components impacted by files specified on STDIN
#+end_example

** Pre-requisites

- Install Babashka: ~brew install borkdude/brew/babashka~
- Install GNU-sed: ~brew install gnu-sed~

** Compiling the bb-components script

Clone this repository, ~cd~ into it and run the following commands: (Note: If you are on a Linux machine, replace ~gsed~ with ~sed~ in the instructions)
#+begin_src sh :eval no
  # Create the target directory for building the compiled scripts
  mkdir target
  # Compile the components script
  bb uberscript target/bb-components -m me.vedang.scripts.components
  # Add a directive to tell the system that this is a bb script
  gsed -i '1s/^/#!\/usr\/bin\/env bb\n/' target/bb-components
  # Make the script executable
  chmod a+x target/bb-components
  # Copy the script somewhere on your $PATH, so that it can be used anywhere
  cp target/bb-components /somewhere/in/PATH
#+end_src

** Using the bb-components script

Go to your code repository and run ~bb-components --help~. Read through the output to see all the options the script accepts. The basic usage is to pass two points in git commit history to see what components are affected by the code changes. Example:
#+begin_example
➜ bb-components release-branch master
Components impacted by these code changes:

websupport.service
jobs.runner
webhook.service
websdk.core.service
api.core.service
#+end_example

The script also accepts filenames from stdin. This allows you to remove common files that might impact multiple components, but where you know that adding new data does not require deploying to all components. For example:
#+begin_example
➜ git diff 10.35.2 10.34.0 --name-only | rg -v "(specs|audit_trail).clj$" | bb-components --stdin -v -e src/migrators/
Namespaces changed between these two points

models.site
models.blocking
xhr.blocking

Components impacted by these code changes:

websupport.service => impacted by changes in [models.site models.blocking xhr.blocking]
jobs.runner => impacted by changes in [models.site]
webhook.service => impacted by changes in [models.blocking]
#+end_example

* bb-plain-text-tabs

A script to list all the open tabs in your browser and covert them to plain text in Org-Mode format.

This script uses TabFS to get information of all the open tabs from the browser. To install TabFS, please refer to https://omar.website/tabfs/#setup"

My philosophy on reading / watching content in the browser is: Never read anything just because you have clicked on it.

The internet is full of interesting stuff that hijacks my attention. I end up getting completely distracted from my planned tasks. My solution to this is: I open all the links I want, but I don't read anything immediately. Instead, I capture the link in Org-Mode and schedule it for later (generally tomorrow). This way, when I am planning the day, I have a bunch of links in my Agenda. I choose which ones I want to read on any given day and defer / delete the rest. I use the excellent [[https://orgmode.org/manual/Agenda-Commands.html][Bulk Scatter]] tool built into Org Agenda for this.

Earlier, I was capturing links manually, but now I have automated the task of collecting these links using this script.

#+begin_example
  ✦ ➜ bb-plain-text-tabs --help
  Convert all open tabs to plain text Org Mode format. Optionally, close the open tabs.

  Usage: bb-plain-text-tabs [options]

  Options:
    -fs,  --tabfs-mnt-path                *REQUIRED* TabFS mount path. The path on the filesystem where TabFS is mounted.
    -hl,  --org-mode-heading-level        1                            The heading level at which link headings will be stored in Org Mode.
    -s,   --scheduled-on           <date> tomorrow                     Date on which to schedule reading this batch of links, in yyyy-MM-dd format.
    -del, --delete-tabs            <del>  false                        Boolean value to indicate if browser tabs should be closed

  Examples:
     bb-plain-text-tabs -fs <TabFS Mount Path> # Convert Open Tabs to Plain Text
     bb-plain-text-tabs -fs <TabFS Mount Path> --delete-tabs # Delete tabs and print plain text
     bb-plain-text-tabs -fs <TabFS Mount Path> | tee tabs.org # Capture Plain Text output to file
#+end_example

** Pre-requisites

- Install Babashka: ~brew install borkdude/brew/babashka~
- Install TabFS: https://omar.website/tabfs/#setup
- Install GNU-sed: ~brew install gnu-sed~

** Compiling the bb-plain-text-tabs script

Clone this repository, ~cd~ into it and run the following commands: (Note: If you are on a Linux machine, replace ~gsed~ with ~sed~ in the instructions)
#+begin_src sh :eval no
  # Create the target directory for building the compiled scripts
  mkdir target
  # Compile the components script
  bb uberscript target/bb-plain-text-tabs -m me.vedang.scripts.tablist
  # Add a directive to tell the system that this is a bb script
  gsed -i '1s/^/#!\/usr\/bin\/env bb\n/' target/bb-plain-text-tabs
  # Make the script executable
  chmod a+x target/bb-plain-text-tabs
  # Copy the script somewhere on your $PATH, so that it can be used anywhere
  cp target/bb-plain-text-tabs /somewhere/in/PATH
#+end_src

** Using the bb-plain-text-tabs script

Run ~bb-plain-text-tabs --help~. Read through the output to see all the options the script accepts.
